import { execa } from 'execa';
import type { AgentKind, AgentOutput, Logger, RepoResult } from '../types.ts';
import { consoleLogger } from '../types.ts';
import { CONFIG } from '../config.ts';

/**
 * Checks if a worktree has uncommitted changes
 */
export async function hasChanges(worktreePath: string): Promise<boolean> {
  await execa('git', ['add', '-A'], { cwd: worktreePath });
  const { stdout } = await execa('git', ['status', '--porcelain'], { cwd: worktreePath });
  return stdout.trim().length > 0;
}

/**
 * Commits changes and pushes (branch is already created in scaffold)
 */
export async function commitAndPush(
  worktreePath: string,
  branchName: string,
  flagKey: string,
  logger: Logger = consoleLogger
): Promise<void> {
  logger.log('Staging changes...');
  await execa('git', ['add', '-A'], { cwd: worktreePath });

  // Check if there are changes to commit
  const { stdout: status } = await execa('git', ['status', '--porcelain'], { cwd: worktreePath });
  if (!status.trim()) {
    throw new Error('No changes to commit. The agent may not have made any modifications.');
  }

  logger.log('Committing...');
  await execa(
    'git',
    [
      'commit',
      '-m',
      `Remove feature flag: ${flagKey}

Generated by bye-bye-flag`,
    ],
    { cwd: worktreePath }
  );

  logger.log('Pushing to origin...');
  await execa('git', ['push', '-u', 'origin', branchName], { cwd: worktreePath });
}

/**
 * Commits and pushes changes for multiple repos, creates PRs
 * Returns results for each repo
 */
export async function commitAndPushMultiRepo(
  repos: Array<{ name: string; originalPath: string; worktreePath: string }>,
  branchName: string,
  flagKey: string,
  keepBranch: 'enabled' | 'disabled',
  agentOutput: AgentOutput,
  agentKind: AgentKind,
  sessionId: string | undefined,
  resumeCommand: string,
  flagCreatedBy?: string,
  logger: Logger = consoleLogger
): Promise<RepoResult[]> {
  const results: RepoResult[] = [];

  // First pass: commit and push repos with changes
  for (const repo of repos) {
    try {
      const changed = await hasChanges(repo.worktreePath);
      if (!changed) {
        logger.log(`  ${repo.name}: No changes`);
        results.push({
          repoName: repo.name,
          repoPath: repo.originalPath,
          status: 'no-changes',
        });
        continue;
      }

      logger.log(`  ${repo.name}: Committing and pushing...`);
      await commitAndPush(repo.worktreePath, branchName, flagKey, logger);
      results.push({
        repoName: repo.name,
        repoPath: repo.originalPath,
        status: 'success',
      });
    } catch (error) {
      results.push({
        repoName: repo.name,
        repoPath: repo.originalPath,
        status: 'failed',
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  // Second pass: create PRs with cross-links
  const successfulRepos = results.filter((r) => r.status === 'success');

  for (const result of successfulRepos) {
    const repo = repos.find((r) => r.name === result.repoName)!;
    try {
      const prUrl = await createPR(
        repo.worktreePath,
        flagKey,
        keepBranch,
        agentOutput,
        branchName,
        agentKind,
        sessionId,
        resumeCommand,
        flagCreatedBy,
        successfulRepos.filter((r) => r.repoName !== result.repoName).map((r) => r.repoName),
        logger
      );
      result.prUrl = prUrl;
    } catch (error) {
      result.status = 'failed';
      result.error = `PR creation failed: ${error instanceof Error ? error.message : String(error)}`;
    }
  }

  return results;
}

/**
 * Generates a consistent PR title for a flag removal
 */
export function getPRTitle(flagKey: string): string {
  return `bye-bye-flag: Remove \`${flagKey}\``;
}

export interface ExistingPR {
  url: string;
  state: 'OPEN' | 'CLOSED' | 'MERGED';
  declined: boolean; // True if PR title contains [DECLINED]
  history: PRHistoryEntry[];
}

export interface PRHistoryEntry {
  url: string;
  state: 'OPEN' | 'CLOSED' | 'MERGED';
  declined: boolean;
  createdAt?: string;
}

interface PullRequestSummary {
  url: string;
  state: 'OPEN' | 'CLOSED' | 'MERGED';
  title: string;
  createdAt?: string;
}

interface GitHubPRListItem extends PullRequestSummary {
  headRefName: string;
}

interface FetchPRSafetyStatesOptions {
  headBranch?: string;
  limit?: number;
}

function sortNewestFirst(prs: PullRequestSummary[]): PullRequestSummary[] {
  return [...prs].sort((a, b) => {
    const aTs = a.createdAt ? Date.parse(a.createdAt) : 0;
    const bTs = b.createdAt ? Date.parse(b.createdAt) : 0;
    return bTs - aTs;
  });
}

function resolvePRSafetyState(prs: PullRequestSummary[]): ExistingPR | null {
  if (prs.length === 0) return null;
  const newestFirst = sortNewestFirst(prs);
  const history: PRHistoryEntry[] = newestFirst.map((pr) => ({
    url: pr.url,
    state: pr.state,
    declined: (pr.title || '').includes('[DECLINED]'),
    createdAt: pr.createdAt,
  }));

  const declined = history.find((pr) => pr.declined);
  if (declined) {
    return {
      url: declined.url,
      state: declined.state,
      declined: true,
      history,
    };
  }

  const open = history.find((pr) => pr.state === 'OPEN');
  if (open) {
    return {
      url: open.url,
      state: open.state,
      declined: false,
      history,
    };
  }

  // Fall back to newest entry for logging/metadata.
  const latest = history[0];
  return {
    url: latest.url,
    state: latest.state,
    declined: false,
    history,
  };
}

function groupFlagBranchPRs(prs: GitHubPRListItem[]): Map<string, PullRequestSummary[]> {
  const groupedByFlag = new Map<string, PullRequestSummary[]>();

  for (const pr of prs) {
    if (!pr.headRefName.startsWith(CONFIG.branchPrefix)) continue;
    const flagKey = pr.headRefName.replace(CONFIG.branchPrefix, '');
    const existing = groupedByFlag.get(flagKey) ?? [];
    existing.push({
      url: pr.url,
      state: pr.state,
      title: pr.title,
      createdAt: pr.createdAt,
    });
    groupedByFlag.set(flagKey, existing);
  }

  return groupedByFlag;
}

function resolveSafetyStatesByFlag(prs: GitHubPRListItem[]): Map<string, ExistingPR> {
  const result = new Map<string, ExistingPR>();
  const groupedByFlag = groupFlagBranchPRs(prs);

  for (const [flagKey, flagPRs] of groupedByFlag) {
    const safetyState = resolvePRSafetyState(flagPRs);
    if (safetyState) {
      result.set(flagKey, safetyState);
    }
  }

  return result;
}

async function fetchPRSafetyStates(
  repoPath: string,
  options?: FetchPRSafetyStatesOptions
): Promise<Map<string, ExistingPR>> {
  const args = [
    'pr',
    'list',
    '--state',
    'all',
    '--json',
    'url,state,title,headRefName,createdAt',
  ] as string[];

  if (options?.headBranch) {
    args.push('--head', options.headBranch);
  }

  args.push('--limit', String(options?.limit ?? 500));

  const { stdout } = await execa('gh', args, { cwd: repoPath });
  const prs = JSON.parse(stdout) as GitHubPRListItem[];
  return resolveSafetyStatesByFlag(prs);
}

/**
 * Checks if a PR already exists for this flag's branch (open, closed, or merged)
 * Uses branch name search which is more reliable than title search
 */
export async function findExistingPR(repoPath: string, flagKey: string): Promise<ExistingPR | null> {
  const branchName = `${CONFIG.branchPrefix}${flagKey}`;
  try {
    const byFlag = await fetchPRSafetyStates(repoPath, {
      headBranch: branchName,
      limit: 100,
    });
    return byFlag.get(flagKey) ?? null;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to discover existing PRs for "${flagKey}" in ${repoPath}: ${message}`, {
      cause: error,
    });
  }
}

/**
 * Fetches ALL bye-bye-flag PRs from a repo in a single API call
 * Much more efficient than calling findExistingPR for each flag
 */
export async function fetchAllFlagPRs(repoPath: string): Promise<Map<string, ExistingPR>> {
  try {
    return await fetchPRSafetyStates(repoPath, { limit: 1000 });
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to fetch PRs for ${repoPath}: ${message}`, {
      cause: error,
    });
  }
}

/**
 * Creates a draft PR using GitHub CLI
 */
export async function createPR(
  repoWorktreePath: string,
  flagKey: string,
  keepBranch: 'enabled' | 'disabled',
  agentOutput: AgentOutput,
  branchName: string,
  agentKind: AgentKind,
  sessionId: string | undefined,
  resumeCommand: string,
  flagCreatedBy: string | undefined,
  relatedRepos: string[] = [],
  logger: Logger = consoleLogger
): Promise<string> {
  const body = generatePRBody(
    flagKey,
    keepBranch,
    agentOutput,
    branchName,
    agentKind,
    sessionId,
    resumeCommand,
    flagCreatedBy,
    relatedRepos
  );
  const title = getPRTitle(flagKey);

  logger.log('Creating draft PR...');
  const { stdout } = await execa('gh', ['pr', 'create', '--draft', '--title', title, '--body', body], {
    cwd: repoWorktreePath,
  });

  const prUrl = stdout.trim();
  logger.log(`PR created: ${prUrl}`);
  return prUrl;
}

/**
 * Stages all changes and returns the staged diff.
 *
 * Stages first so new (untracked) files are included in the diff output.
 * Files remain staged so the user can inspect with `git diff --staged` when
 * using `--keep-worktree`.
 */
export async function stageAndDiff(worktreePath: string): Promise<string> {
  await execa('git', ['add', '-A'], { cwd: worktreePath });
  const { stdout } = await execa('git', ['diff', '--staged'], { cwd: worktreePath });
  return stdout;
}

function generatePRBody(
  flagKey: string,
  keepBranch: 'enabled' | 'disabled',
  agentOutput: AgentOutput,
  branchName: string,
  agentKind: AgentKind,
  sessionId: string | undefined,
  resumeCommand: string,
  flagCreatedBy: string | undefined,
  relatedRepos: string[] = []
): string {
  const filesChangedList = agentOutput.filesChanged.map((f) => `- \`${f}\``).join('\n');

  const checksPass = agentOutput.testsPass && agentOutput.lintPass && agentOutput.typecheckPass;
  const failedChecks = [
    { key: 'tests' as const, label: 'Tests', pass: agentOutput.testsPass },
    { key: 'lint' as const, label: 'Lint', pass: agentOutput.lintPass },
    { key: 'typecheck' as const, label: 'Typecheck', pass: agentOutput.typecheckPass },
  ].filter((check) => !check.pass);

  const failedChecksList = failedChecks.map((check) => `- ${check.label}`).join('\n');
  const failureDetailLines = failedChecks
    .map((check) => {
      const detail = agentOutput.verificationDetails?.[check.key];
      if (!detail) return null;
      const normalizedDetail = detail.replace(/\s+/g, ' ').trim();
      if (!normalizedDetail) return null;
      return `- **${check.label}:** ${normalizedDetail}`;
    })
    .filter((line): line is string => line !== null)
    .join('\n');

  const verificationFailureSection = !checksPass
    ? `
### Verification Failures
${failedChecksList}

${failureDetailLines ? `### Failure Details\n${failureDetailLines}` : '_No extra failure details were provided by the agent._'}
`
    : '';

  const relatedReposSection =
    relatedRepos.length > 0
      ? `
## Related PRs

This flag is also being removed from:
${relatedRepos.map((r) => `- \`${r}\` (same branch: \`${branchName}\`)`).join('\n')}

_Check for PRs with the same branch name in those repos._
`
      : '';

  const creatorSection = flagCreatedBy
    ? `
## Flag Metadata
- **Flag creator (from provider):** \`${flagCreatedBy}\`
`
    : '';

  return `> ü§ñ This PR was automatically generated by [bye-bye-flag](https://github.com/RelevanceAI/bye-bye-flag) using \`${agentKind}\`.

## Summary

Remove feature flag \`${flagKey}\` (keeping ${keepBranch} branch).

${agentOutput.summary}
${creatorSection}
${relatedReposSection}
## Changes
${filesChangedList || '_No files listed_'}

## Verification
- [${agentOutput.testsPass ? 'x' : ' '}] Tests pass
- [${agentOutput.lintPass ? 'x' : ' '}] Lint pass
- [${agentOutput.typecheckPass ? 'x' : ' '}] Typecheck pass

${!checksPass ? '‚ö†Ô∏è **Some checks failed. Please review before merging.**' : ''}
${verificationFailureSection}

---

<details>
<summary>Metadata (for resume/conflict resolution)</summary>

- **Flag key:** \`${flagKey}\`
- **Kept branch:** \`${keepBranch}\`
- **Agent:** \`${agentKind}\`
${sessionId ? `- **Session ID:** \`${sessionId}\`` : ''}
- **Generated by:** [bye-bye-flag](https://github.com/RelevanceAI/bye-bye-flag)

**To resume this agent session** (from the same machine):
\`\`\`bash
${resumeCommand}
\`\`\`

**If this PR is declined:** Add \`[DECLINED]\` to the PR title to prevent future removal attempts for this flag.

</details>
`;
}
