import { execa } from 'execa';
import type { AgentOutput, RepoResult } from '../types.ts';

/**
 * Checks if a worktree has uncommitted changes
 */
export async function hasChanges(worktreePath: string): Promise<boolean> {
  await execa('git', ['add', '-A'], { cwd: worktreePath });
  const { stdout } = await execa('git', ['status', '--porcelain'], { cwd: worktreePath });
  return stdout.trim().length > 0;
}

/**
 * Commits changes and pushes (branch is already created in scaffold)
 */
export async function commitAndPush(
  worktreePath: string,
  branchName: string,
  flagKey: string
): Promise<void> {
  console.log('Staging changes...');
  await execa('git', ['add', '-A'], { cwd: worktreePath });

  // Check if there are changes to commit
  const { stdout: status } = await execa('git', ['status', '--porcelain'], { cwd: worktreePath });
  if (!status.trim()) {
    throw new Error('No changes to commit. The agent may not have made any modifications.');
  }

  console.log('Committing...');
  await execa(
    'git',
    [
      'commit',
      '-m',
      `Remove feature flag: ${flagKey}

Generated by bye-bye-flag`,
    ],
    { cwd: worktreePath }
  );

  console.log('Pushing to origin...');
  await execa('git', ['push', '-u', 'origin', branchName], { cwd: worktreePath });
}

/**
 * Commits and pushes changes for multiple repos, creates PRs
 * Returns results for each repo
 */
export async function commitAndPushMultiRepo(
  repos: Array<{ name: string; originalPath: string; worktreePath: string }>,
  branchName: string,
  flagKey: string,
  keepBranch: 'enabled' | 'disabled',
  agentOutput: AgentOutput
): Promise<RepoResult[]> {
  const results: RepoResult[] = [];
  const prUrls: string[] = [];

  // First pass: commit and push repos with changes
  for (const repo of repos) {
    try {
      const changed = await hasChanges(repo.worktreePath);
      if (!changed) {
        console.log(`  ${repo.name}: No changes`);
        results.push({
          repoName: repo.name,
          repoPath: repo.originalPath,
          status: 'no-changes',
        });
        continue;
      }

      console.log(`  ${repo.name}: Committing and pushing...`);
      await commitAndPush(repo.worktreePath, branchName, flagKey);
      results.push({
        repoName: repo.name,
        repoPath: repo.originalPath,
        status: 'success',
      });
    } catch (error) {
      results.push({
        repoName: repo.name,
        repoPath: repo.originalPath,
        status: 'failed',
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  // Second pass: create PRs with cross-links
  const successfulRepos = results.filter((r) => r.status === 'success');

  for (const result of successfulRepos) {
    const repo = repos.find((r) => r.name === result.repoName)!;
    try {
      const prUrl = await createPR(
        repo.worktreePath,
        flagKey,
        keepBranch,
        agentOutput,
        branchName,
        successfulRepos.filter((r) => r.repoName !== result.repoName).map((r) => r.repoName)
      );
      result.prUrl = prUrl;
      prUrls.push(prUrl);
    } catch (error) {
      result.status = 'failed';
      result.error = `PR creation failed: ${error instanceof Error ? error.message : String(error)}`;
    }
  }

  return results;
}

/**
 * Creates a draft PR using GitHub CLI
 */
export async function createPR(
  worktreePath: string,
  flagKey: string,
  keepBranch: 'enabled' | 'disabled',
  agentOutput: AgentOutput,
  branchName: string,
  relatedRepos: string[] = []
): Promise<string> {
  const body = generatePRBody(flagKey, keepBranch, agentOutput, branchName, relatedRepos);

  console.log('Creating draft PR...');
  const { stdout } = await execa(
    'gh',
    ['pr', 'create', '--draft', '--title', `Remove feature flag: ${flagKey}`, '--body', body],
    { cwd: worktreePath }
  );

  const prUrl = stdout.trim();
  console.log(`PR created: ${prUrl}`);
  return prUrl;
}

/**
 * Shows the diff (for dry-run mode)
 * Stages all changes first to include new files in diff
 * Leaves files staged so user can inspect with git diff --staged if using --keep-worktree
 */
export async function showDiff(worktreePath: string): Promise<string> {
  await execa('git', ['add', '-A'], { cwd: worktreePath });
  const { stdout } = await execa('git', ['diff', '--staged'], { cwd: worktreePath });
  return stdout;
}

function generatePRBody(
  flagKey: string,
  keepBranch: 'enabled' | 'disabled',
  agentOutput: AgentOutput,
  branchName: string,
  relatedRepos: string[] = []
): string {
  const filesChangedList = agentOutput.filesChanged.map((f) => `- \`${f}\``).join('\n');

  const checksPass = agentOutput.testsPass && agentOutput.lintPass && agentOutput.typecheckPass;

  const relatedReposSection =
    relatedRepos.length > 0
      ? `
## Related PRs

This flag is also being removed from:
${relatedRepos.map((r) => `- \`${r}\` (same branch: \`${branchName}\`)`).join('\n')}

_Check for PRs with the same branch name in those repos._
`
      : '';

  return `> ü§ñ This PR was automatically generated by bye-bye-flag.

## Summary

Remove feature flag \`${flagKey}\` (keeping ${keepBranch} branch).

${agentOutput.summary}
${relatedReposSection}
## Changes
${filesChangedList || '_No files listed_'}

## Verification
- [${agentOutput.testsPass ? 'x' : ' '}] Tests pass
- [${agentOutput.lintPass ? 'x' : ' '}] Lint pass
- [${agentOutput.typecheckPass ? 'x' : ' '}] Typecheck pass

${!checksPass ? '‚ö†Ô∏è **Some checks failed. Please review before merging.**' : ''}

---

<details>
<summary>Metadata (for conflict resolution)</summary>

- **Flag key:** \`${flagKey}\`
- **Kept branch:** \`${keepBranch}\`
- **Generated by:** bye-bye-flag

To resolve conflicts:
\`\`\`bash
git checkout ${branchName}
git rebase main
npx bye-bye-flag resume --branch=${branchName}
\`\`\`

</details>
`;
}
