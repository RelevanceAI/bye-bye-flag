import { execa } from 'execa';
import type { AgentKind, AgentOutput, RepoResult } from '../types.ts';
import { CONFIG } from '../config.ts';

/**
 * Checks if a worktree has uncommitted changes
 */
export async function hasChanges(worktreePath: string): Promise<boolean> {
  await execa('git', ['add', '-A'], { cwd: worktreePath });
  const { stdout } = await execa('git', ['status', '--porcelain'], { cwd: worktreePath });
  return stdout.trim().length > 0;
}

/**
 * Commits changes and pushes (branch is already created in scaffold)
 */
export async function commitAndPush(
  worktreePath: string,
  branchName: string,
  flagKey: string
): Promise<void> {
  console.log('Staging changes...');
  await execa('git', ['add', '-A'], { cwd: worktreePath });

  // Check if there are changes to commit
  const { stdout: status } = await execa('git', ['status', '--porcelain'], { cwd: worktreePath });
  if (!status.trim()) {
    throw new Error('No changes to commit. The agent may not have made any modifications.');
  }

  console.log('Committing...');
  await execa(
    'git',
    [
      'commit',
      '-m',
      `Remove feature flag: ${flagKey}

Generated by bye-bye-flag`,
    ],
    { cwd: worktreePath }
  );

  console.log('Pushing to origin...');
  await execa('git', ['push', '-u', 'origin', branchName], { cwd: worktreePath });
}

/**
 * Commits and pushes changes for multiple repos, creates PRs
 * Returns results for each repo
 */
export async function commitAndPushMultiRepo(
  repos: Array<{ name: string; originalPath: string; worktreePath: string }>,
  branchName: string,
  flagKey: string,
  keepBranch: 'enabled' | 'disabled',
  agentOutput: AgentOutput,
  agentKind: AgentKind,
  sessionId: string | undefined,
  workspacePath: string,
  flagCreatedBy?: string
): Promise<RepoResult[]> {
  const results: RepoResult[] = [];
  const prUrls: string[] = [];

  // First pass: commit and push repos with changes
  for (const repo of repos) {
    try {
      const changed = await hasChanges(repo.worktreePath);
      if (!changed) {
        console.log(`  ${repo.name}: No changes`);
        results.push({
          repoName: repo.name,
          repoPath: repo.originalPath,
          status: 'no-changes',
        });
        continue;
      }

      console.log(`  ${repo.name}: Committing and pushing...`);
      await commitAndPush(repo.worktreePath, branchName, flagKey);
      results.push({
        repoName: repo.name,
        repoPath: repo.originalPath,
        status: 'success',
      });
    } catch (error) {
      results.push({
        repoName: repo.name,
        repoPath: repo.originalPath,
        status: 'failed',
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  // Second pass: create PRs with cross-links
  const successfulRepos = results.filter((r) => r.status === 'success');

  for (const result of successfulRepos) {
    const repo = repos.find((r) => r.name === result.repoName)!;
    try {
      const prUrl = await createPR(
        repo.worktreePath,
        flagKey,
        keepBranch,
        agentOutput,
        branchName,
        agentKind,
        sessionId,
        workspacePath,
        flagCreatedBy,
        successfulRepos.filter((r) => r.repoName !== result.repoName).map((r) => r.repoName)
      );
      result.prUrl = prUrl;
      prUrls.push(prUrl);
    } catch (error) {
      result.status = 'failed';
      result.error = `PR creation failed: ${error instanceof Error ? error.message : String(error)}`;
    }
  }

  return results;
}

/**
 * Generates a consistent PR title for a flag removal
 */
export function getPRTitle(flagKey: string): string {
  return `bye-bye-flag: Remove \`${flagKey}\``;
}

export interface ExistingPR {
  url: string;
  state: 'OPEN' | 'CLOSED' | 'MERGED';
  declined: boolean; // True if PR title contains [DECLINED]
}

/**
 * Checks if a PR already exists for this flag's branch (open, closed, or merged)
 * Uses branch name search which is more reliable than title search
 */
export async function findExistingPR(repoPath: string, flagKey: string): Promise<ExistingPR | null> {
  const branchName = `${CONFIG.branchPrefix}${flagKey}`;
  try {
    // Search for PRs with this head branch (any state)
    const { stdout } = await execa(
      'gh',
      ['pr', 'list', '--head', branchName, '--state', 'all', '--json', 'url,state,title', '--limit', '1'],
      { cwd: repoPath }
    );
    const prs = JSON.parse(stdout);
    if (prs.length > 0) {
      const title: string = prs[0].title || '';
      return {
        url: prs[0].url,
        state: prs[0].state,
        declined: title.includes('[DECLINED]'),
      };
    }
    return null;
  } catch {
    // gh command failed, assume no existing PR
    return null;
  }
}

/**
 * Fetches ALL bye-bye-flag PRs from a repo in a single API call
 * Much more efficient than calling findExistingPR for each flag
 */
export async function fetchAllFlagPRs(
  repoPath: string
): Promise<Map<string, ExistingPR>> {
  const result = new Map<string, ExistingPR>();

  try {
    // Fetch all PRs (any state) - we'll filter by branch prefix
    // Using search query for branches starting with our branch prefix
    const { stdout } = await execa(
      'gh',
      [
        'pr',
        'list',
        '--state',
        'all',
        '--json',
        'url,state,title,headRefName',
        '--limit',
        '500', // Should be enough for most repos
      ],
      { cwd: repoPath }
    );

    const prs = JSON.parse(stdout) as Array<{
      url: string;
      state: 'OPEN' | 'CLOSED' | 'MERGED';
      title: string;
      headRefName: string;
    }>;

    for (const pr of prs) {
      // Only include PRs from our branches
      if (pr.headRefName.startsWith(CONFIG.branchPrefix)) {
        const flagKey = pr.headRefName.replace(CONFIG.branchPrefix, '');
        result.set(flagKey, {
          url: pr.url,
          state: pr.state,
          declined: pr.title.includes('[DECLINED]'),
        });
      }
    }
  } catch {
    // gh command failed, return empty map
  }

  return result;
}

/**
 * Creates a draft PR using GitHub CLI
 */
export async function createPR(
  repoWorktreePath: string,
  flagKey: string,
  keepBranch: 'enabled' | 'disabled',
  agentOutput: AgentOutput,
  branchName: string,
  agentKind: AgentKind,
  sessionId: string | undefined,
  workspacePath: string,
  flagCreatedBy: string | undefined,
  relatedRepos: string[] = []
): Promise<string> {
  const body = generatePRBody(
    flagKey,
    keepBranch,
    agentOutput,
    branchName,
    agentKind,
    sessionId,
    workspacePath,
    flagCreatedBy,
    relatedRepos
  );
  const title = getPRTitle(flagKey);

  console.log('Creating draft PR...');
  const { stdout } = await execa(
    'gh',
    ['pr', 'create', '--draft', '--title', title, '--body', body],
    { cwd: repoWorktreePath }
  );

  const prUrl = stdout.trim();
  console.log(`PR created: ${prUrl}`);
  return prUrl;
}

/**
 * Shows the diff (for dry-run mode)
 * Stages all changes first to include new files in diff
 * Leaves files staged so user can inspect with git diff --staged if using --keep-worktree
 */
export async function showDiff(worktreePath: string): Promise<string> {
  await execa('git', ['add', '-A'], { cwd: worktreePath });
  const { stdout } = await execa('git', ['diff', '--staged'], { cwd: worktreePath });
  return stdout;
}

function generatePRBody(
  flagKey: string,
  keepBranch: 'enabled' | 'disabled',
  agentOutput: AgentOutput,
  branchName: string,
  agentKind: AgentKind,
  sessionId: string | undefined,
  workspacePath: string,
  flagCreatedBy: string | undefined,
  relatedRepos: string[] = []
): string {
  const filesChangedList = agentOutput.filesChanged.map((f) => `- \`${f}\``).join('\n');

  const checksPass = agentOutput.testsPass && agentOutput.lintPass && agentOutput.typecheckPass;
  const failedChecks = [
    { key: 'tests' as const, label: 'Tests', pass: agentOutput.testsPass },
    { key: 'lint' as const, label: 'Lint', pass: agentOutput.lintPass },
    { key: 'typecheck' as const, label: 'Typecheck', pass: agentOutput.typecheckPass },
  ].filter((check) => !check.pass);

  const failedChecksList = failedChecks.map((check) => `- ${check.label}`).join('\n');
  const failureDetailLines = failedChecks
    .map((check) => {
      const detail = agentOutput.verificationDetails?.[check.key];
      if (!detail) return null;
      const normalizedDetail = detail.replace(/\s+/g, ' ').trim();
      if (!normalizedDetail) return null;
      return `- **${check.label}:** ${normalizedDetail}`;
    })
    .filter((line): line is string => line !== null)
    .join('\n');

  const verificationFailureSection = !checksPass
    ? `
### Verification Failures
${failedChecksList}

${failureDetailLines ? `### Failure Details\n${failureDetailLines}` : '_No extra failure details were provided by the agent._'}
`
    : '';

  const relatedReposSection =
    relatedRepos.length > 0
      ? `
## Related PRs

This flag is also being removed from:
${relatedRepos.map((r) => `- \`${r}\` (same branch: \`${branchName}\`)`).join('\n')}

_Check for PRs with the same branch name in those repos._
`
      : '';

  const creatorSection = flagCreatedBy
    ? `
## Flag Metadata
- **Flag creator (from provider):** \`${flagCreatedBy}\`
`
    : '';

  return `> ü§ñ This PR was automatically generated by [bye-bye-flag](https://github.com/RelevanceAI/bye-bye-flag) using \`${agentKind}\`.

## Summary

Remove feature flag \`${flagKey}\` (keeping ${keepBranch} branch).

${agentOutput.summary}
${creatorSection}
${relatedReposSection}
## Changes
${filesChangedList || '_No files listed_'}

## Verification
- [${agentOutput.testsPass ? 'x' : ' '}] Tests pass
- [${agentOutput.lintPass ? 'x' : ' '}] Lint pass
- [${agentOutput.typecheckPass ? 'x' : ' '}] Typecheck pass

${!checksPass ? '‚ö†Ô∏è **Some checks failed. Please review before merging.**' : ''}
${verificationFailureSection}

---

<details>
<summary>Metadata (for resume/conflict resolution)</summary>

- **Flag key:** \`${flagKey}\`
- **Kept branch:** \`${keepBranch}\`
- **Agent:** \`${agentKind}\`
${sessionId ? `- **Session ID:** \`${sessionId}\`` : ''}
- **Generated by:** [bye-bye-flag](https://github.com/RelevanceAI/bye-bye-flag)

**To resume this agent session** (from the same machine):
\`\`\`bash
${getResumeCommand(agentKind, sessionId, workspacePath)}
\`\`\`

**If this PR is declined:** Add \`[DECLINED]\` to the PR title to prevent future removal attempts for this flag.

</details>
`;
}

function getResumeCommand(agentKind: AgentKind, sessionId: string | undefined, workspacePath: string): string {
  if (agentKind === 'claude') {
    return sessionId
      ? `cd ${workspacePath} && claude --resume ${sessionId}`
      : `cd ${workspacePath} && claude --resume <session-id>`;
  }

  // Codex CLI
  return sessionId
    ? `cd ${workspacePath} && codex resume ${sessionId}`
    : `cd ${workspacePath} && codex resume --all`;
}
